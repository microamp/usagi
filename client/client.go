package main

import (
	"fmt"
	"log"
	"math/rand"
	"os"
	"os/exec"
	"strconv"
	"time"

	"github.com/streadway/amqp"
)

const (
	host         = "amqp://guest:guest@localhost:5672/"
	exchangeName = "usagi-test-x-consistent-hash"
)

func genUUID() (string, error) {
	out, err := exec.Command("uuidgen").Output()
	if err != nil {
		return "", err
	}
	return string(out), nil
}

func genRoutingKey() string {
	rand.Seed(time.Now().UTC().UnixNano())
	return fmt.Sprintf("%d", rand.Intn(100))
}

func main() {
	log.Printf("Usagi client started")

	msg, msgCount := os.Args[1], os.Args[2]

	msgCountInt, err := strconv.Atoi(msgCount)
	if err != nil {
		log.Panicf("Invalid message count: %s", err)
	}

	// Open connection
	conn, err := amqp.Dial(host)
	if err != nil {
		log.Panicf("Error connecting to host: %s", err)
	}
	defer func() {
		err = conn.Close()
		if err != nil {
			log.Panicf("Error closing connection: %s", err)
		}
	}()

	// Open channel
	ch, err := conn.Channel()
	if err != nil {
		log.Panicf("Error opening channel: %s", err)
	}
	defer func() {
		err = ch.Close()
		if err != nil {
			log.Panicf("Error closing channel: %s", err)
		}
	}()

	// Declare exchange
	err = ch.ExchangeDeclare(
		exchangeName,        // name
		"x-consistent-hash", // kind
		true,                // durable
		false,               // autoDelete
		false,               // internal
		false,               // noWait
		nil,                 // args
	)
	if err != nil {
		log.Panicf("Error declaring exchange: %s", err)
	}
	log.Printf("Exchange declared: %s", exchangeName)

	// Declare reply queue
	qReply, err := ch.QueueDeclare(
		"",    // name (autogenerated)
		false, // durable
		false, // autoDelete
		true,  // exclusive (deleted when it is disconnected)
		false, // noWait
		nil,   // args
	)
	if err != nil {
		log.Panicf("Error declaring reply queue: %s", err)
	}
	log.Printf("Reply queue declared: %s", qReply.Name)

	forever := make(chan bool)

	go func() {
		for i := 0; i < msgCountInt; i++ {
			// Generate random correleation ID
			correlationID, err := genUUID()
			if err != nil {
				log.Panicf("Error generating UUID: %s", err)
			}
			log.Printf("Random correlation ID generated: %s", correlationID)

			// Generate random routing key
			routingKey := genRoutingKey()
			log.Printf("Random routing key generated: %s", routingKey)

			// Publish message
			err = ch.Publish(
				exchangeName, // exchange
				routingKey,   // key
				false,        // mandatory
				false,        // immediate
				amqp.Publishing{ // msg
					ContentType:   "text/plain",
					DeliveryMode:  amqp.Transient,
					ReplyTo:       qReply.Name,
					CorrelationId: correlationID,
					Body:          []byte(fmt.Sprintf("%s #%d", msg, i+1)),
				},
			)
			if err != nil {
				log.Panicf("Error publishing message: %s", err)
			}

			log.Printf("Message published: %s", msg)
		}
	}()

	go func() {
		msgs, err := ch.Consume(
			qReply.Name, // queue
			"",          // consumer
			false,       // autoAck
			true,        // exclusive
			false,       // noLocal
			false,       // noWait
			nil,         // args
		)
		if err != nil {
			log.Panicf("Error consuming replies: %s", err)
		}

		for d := range msgs {
			log.Printf("Reply consumed: %s", d.Body)
			err = d.Ack(false)
			if err != nil {
				log.Panicf("Error send ack after processing message: %s", err)
			}
		}
	}()

	<-forever
}
