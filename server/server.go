package main

import (
	"fmt"
	"log"
	"os"

	"github.com/streadway/amqp"
)

const (
	host         = "amqp://guest:guest@localhost:5672/"
	exchangeName = "usagi-test-x-consistent-hash"
)

func main() {
	log.Printf("Usagi server started")

	bindingKey := os.Args[1] // Expect number-as-string (number of points in the hash space)

	// Open connection
	conn, err := amqp.Dial(host)
	if err != nil {
		log.Panicf("Error connecting to host: %s", err)
	}
	defer func() {
		err = conn.Close()
		if err != nil {
			log.Panicf("Error closing connection: %s", err)
		}
	}()

	// Open channel
	ch, err := conn.Channel()
	if err != nil {
		log.Panicf("Error opening channel: %s", err)
	}
	defer func() {
		err = ch.Close()
		if err != nil {
			log.Panicf("Error closing channel: %s", err)
		}
	}()

	// Declare exchange
	err = ch.ExchangeDeclare(
		exchangeName,        // name
		"x-consistent-hash", // kind
		true,                // durable
		false,               // autoDelete
		false,               // internal
		false,               // noWait
		nil,                 // args
	)
	if err != nil {
		log.Panicf("Error declaring exchange: %s", err)
	}
	log.Printf("Exchange declared: %s", exchangeName)

	// Declare queue
	q, err := ch.QueueDeclare(
		"",    // name (autogenerated)
		false, // durable
		false, // autoDelete
		true,  // exclusive (deleted when it is disconnected)
		false, // noWait
		nil,   // args
	)
	if err != nil {
		log.Panicf("Error declaring queue: %s", err)
	}
	log.Printf("Queue declared: %s", q.Name)

	// Bind queue
	err = ch.QueueBind(
		q.Name,       // name
		bindingKey,   // key
		exchangeName, // exchange
		false,        // noWait
		nil,          // args
	)
	if err != nil {
		log.Panicf("Error binding queue: %s", err)
	}

	forever := make(chan bool)

	go func() {
		// Consume messages
		msgs, err := ch.Consume(
			q.Name, // queue
			"",     // consumer
			false,  // autoAck (ack manually)
			true,   // exclusive
			false,  // noLocal
			false,  // noWait
			nil,    // args
		)
		if err != nil {
			log.Panicf("Error consuming messages: %s", err)
		}

		for d := range msgs {
			log.Printf("Message consumed: %s", d.Body)

			reply := fmt.Sprintf("Hello, %s!", d.Body)
			err = ch.Publish(
				"",        // exchange
				d.ReplyTo, // key
				false,     // mandatory
				false,     // immediate
				amqp.Publishing{ // msg
					ContentType:   "text/plain",
					DeliveryMode:  amqp.Transient,
					CorrelationId: d.CorrelationId,
					Body:          []byte(reply),
				},
			)
			if err != nil {
				log.Panicf("Error replying: %s", err)
			}
			log.Printf("Reply published: %s", reply)

			err = d.Ack(false)
			if err != nil {
				log.Panicf("Error while sending ack: %s", err)
			}
		}
	}()

	log.Printf("Consuming messages...")

	<-forever
}
